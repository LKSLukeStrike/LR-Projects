//region LR_Elems (aka components in LR)
//region LR_Elems Events
const Evt_Click  = "click"
const Evt_Update = "update"
function onElemEvtFct(elem, evt, fct) {
	debugFA("onElemEvtFct", arguments)
	return elem.on(evt, fct)
}
function onElemClickFct(elem, fct) {
	debugFA("onElemClickFct", arguments)
	return onElemEvtFct(elem, Evt_Click, fct)
}
function onElemUpdateFct(elem, fct) {
	debugFA("onElemUpdateFct", arguments)
	return onElemEvtFct(elem, Evt_Update, fct)
}
function onElemChildEvtFct(elem, child, evt, fct) {
	debugFA("onElemChildEvtFct", arguments)
	return elem.on(evt, child, fct)
}
function onElemChildClickFct(elem, child, fct) {
	debugFA("onElemChildClickFct", arguments)
	return onElemChildEvtFct(elem, child, Evt_Click, fct)
}
function onElemChildUpdateFct(elem, child, fct) {
	debugFA("onElemChildUpdateFct", arguments)
	return onElemChildEvtFct(elem, child, Evt_Update, fct)
}
//endregion

//region LR_Elems Attributes
function getElemParent(elem) {
	debugFA("getElemParent", arguments)
	let result = null
	try { // skip error when no parent
		result = elem.parent()
	} catch {}
	return result
}
function getElemChild(elem, child) {
	debugFA("getElemChild", arguments)
	let result = null
	try { // skip error when no child
		result = elem.find(child)
	} catch {}
	return result
}
function getElemSheet(elem) {
	debugFA("getElemSheet", arguments)
	let result = null
	try { // skip error when no sheet
		result = elem.sheet()
	} catch {}
	return result
}
function getElemName(elem) {
	debugFA("getElemName", arguments)
	let result = null
	try { // skip error when no name
		result = elem.name()
	} catch {}
	return result
}
function getElemId(elem) {
	debugFA("getElemId", arguments)
	let result = null
	try { // skip error when no id
		result = elem.id()
	} catch {}
	return result
}
function getElemItem(elem) { // item is the id (aliases)
	debugFA("getElemItem", arguments)
	return getElemId(elem)
}
function getElemIndex(elem) {
	debugFA("getElemIndex", arguments)
	let result = null
	try { // skip error when no index
		result = elem.index()
	} catch {}
	return result
}
function getElemTypeof(elem) {
	debugFA("getElemTypeof", arguments)
	return typeof elem
}
function getElemChildren(elem) { // return children ids (get them with find)
	debugFA("getElemChildren", arguments)
	const elm_value = getElemValue(elem)
	if (notElem(elm_value)) {return Arr_None} // not an elem so no children
	return Object.keys(elm_value)
}
//endregion

//region LR_Elems Values
function getElemValue(elem) {
	debugFA("getElemValue", arguments)
	const elm_value = elem.value()
	return Number.isNaN(Number(elm_value)) ? // right type
		elm_value : Number(elm_value)
}
function setElemValue(elem, elm_value) {
	debugFA("setElemValue", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		setElemValue(elem, elm_value)
	})} // single elem from here
	elm_value = hasElemPlussigned(elem) && gthValue(elm_value, Int_Zero) ? // add + ?
		pfxValue(elm_value, Str_Plus) : elm_value
	elem.value(elm_value)
	setElemDotted(elem) // dotted representation if any
	return elm_value
}
function rsaElemValue(elem, value_str, value_rpl) { // replace a string all
	debugFA("rsaElemValue", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		rsaElemValue(elem, value_str, value_rpl)
	})} // single elem from here
	const elm_value = rsaValue(getElemValue(elem), value_str, value_rpl)
	return setElemValue(elem, elm_value)
}
function hasElemValue(elem, elm_value) {
	debugFA("hasElemValue", arguments)
	return equValue(getElemValue(elem), elm_value)
}
function ysiElemValue(elem, value_str) { // if includes a string
	debugFA("ysiElemValue", arguments)
	return ysiValue(getElemValue(elem), value_str)
}
//endregion

//region LR_Elems Css Classes
const Css_DFlex			  = "d-flex" // add/remove for displayed on containers to work
const Css_WidgetContainer = "widget-container" // identify a container
const Css_DNone			  = "d-none"
const Css_Clickable		  = "clickable"
const Css_BgSecondary     = "bg-secondary"
const Css_Repeater        = "repeater"
const Css_RepeaterElement = "repeater-element"
function yesDFlexElem(elem) { // if require to add/rem dflex
	debugFA("yesDFlexElem", arguments)
	let result = hasElemCss(elem, Css_WidgetContainer)
	return result
}
function yesDFlexCss(css) { // if require to add/rem dflex
	debugFA("yesDFlexCss", arguments)
	let result = equValue(css, Css_DNone)
	return result
}
function yesDFlex(elem, css) { // if require to add/rem dflex
	debugFA("yesDFlex", arguments)
	let result = yesDFlexElem(elem) && yesDFlexCss(css)
	return result
}
function addElemCss(elem, css) { // multiple css allowed in one string
	debugFA("addElemCss", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		addElemCss(elem, css)
	})} // single elem from here
	css.split(Str_Space).forEach(function(css) {
		try { // skip error when no css classes
			if (yesDFlex(elem, css)) {
				elem.removeClass(Css_DFlex)
			}
			elem.addClass(css)
		} catch {}
	})
	return css
}
function remElemCss(elem, css) { // multiple css allowed in one string
	debugFA("remElemCss", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		remElemCss(elem, css)
	})} // single elem from here
	css.split(Str_Space).forEach(function(css) {
		try { // skip error when no css classes
			if (yesDFlex(elem, css)) {
				elem.addClass(Css_DFlex)
			}
			elem.removeClass(css)
		} catch {}
	})
	return css
}
function hasElemCss(elem, css) { // multiple css allowed in one string
	debugFA("hasElemCss", arguments)
	let result = true
	css.split(Str_Space).forEach(function(css) { // every css has to be present
		try { // skip error when no css classes
			if (! elem.hasClass(css)) {result = false}
		} catch {
			result = false
		}
	})
	return result
}
function getElemCss(elem) {
	debugFA("getElemCss", arguments)
	let result = Arr_None
	try { // skip error when no css classes
		result = elem.getClasses()
	} catch {}
	return result
}
//endregion

//region LR_Elems Cfk Classes
const Cfk_Effort      = "Cfk_Effort"		// has an effort related item
const Cfk_Dotted10    = "Cfk_Dotted10"		// has a dotted10 value representation
const Cfk_Plussigned  = "Cfk_Plussigned"	// allows to show "+" for positive values
const Cfk_Undisplayed = "Cfk_Undisplayed"	// allows to show/hide items
const Cfk_Clickable   = "Cfk_Clickable"		// allows to react to onclick
const Cfk_Modifiable  = "Cfk_Modifiable"	// allows only dec, inc
const Cfk_Selected    = "Cfk_Selected"		// allows only rej, inj
const Cfk_Fakeupdated = "Cfk_Fakeupdated"	// avoid computations propagation
const Key_CfkCss      = { // relation between cfk and css /!\ space to separate
	Cfk_Effort        : Cfk_Effort      ,
	Cfk_Dotted10      : Cfk_Dotted10    ,
	Cfk_Plussigned    : Cfk_Plussigned  ,
	Cfk_Undisplayed   : Cfk_Undisplayed + Str_Space + Css_DNone,
	Cfk_Clickable     : Cfk_Clickable   + Str_Space + Css_Clickable,
	Cfk_Modifiable    : Cfk_Modifiable  ,
	Cfk_Selected      : Cfk_Selected    + Str_Space + Css_BgSecondary,
	Cfk_Fakeupdated   : Cfk_Fakeupdated ,
}
const Arr_THMCFK      = [ // cfk that support theme
	Cfk_Clickable,
	Cfk_Modifiable,
	Cfk_Selected,
]	
function yesCfkTheme(cfk) { // if cfk support theme
	debugFA("yesCfkTheme", arguments)
	return yaiValue(Arr_THMCFK, cfk)
}
function getElemCfkCss(elem, cfk) { // full corresponding css
	debugFA("getElemCfkCss", arguments)
	let result = Key_CfkCss[cfk]
	if (yesCfkTheme(cfk)) { // add the elem sheet theme if any
		try { // skip error if any
			const elm_sheet = getElemSheet(elem)
			const prf_theme = getSheetThemePrf(elm_sheet)
			result = result + Str_Space + prf_theme
		} catch {}
	}
	return result
}
//endregion

//region LR_Elems Repeaters
function rptElemDoIf(elem, _do_fct, _if_fct) { // apply fct on repeater if true
	debugFA("rptElemDoIf", arguments)
	if (arguments.length < 3) { // filter function
		_if_fct = function(elem) {
			debugFA("rptElemDoIf_if_fct", arguments)
			return true // true to do action function
		}
	}
	if (arguments.length < 2) { // action function
		_do_fct = function(elem) {
			debugFA("rptElemDoIf_do_fct", arguments)
			debugElem(elem, Yes_Debug, Yes_Indent)
			return true // true to continue recursive
		}
	}
	if (notElem(elem)) {return} // not an elem
	if (_if_fct(elem)) {
		// if (! _do_fct(elem)) {return} // /!\ repeat twice (why ?)
		const yes_recursive = _do_fct(elem)
		if (! yes_recursive) {return} // interrupt recursive 
	}
	// getElemChildren(elem).forEach(function(child) // /!\ repeat twice (why ?)
	const elm_children = getElemChildren(elem) 
	elm_children.forEach(function(child) { // recursive
		rptElemDoIf(getElemChild(elem, child), _do_fct, _if_fct)
	})
}
//endregion
//endregion
