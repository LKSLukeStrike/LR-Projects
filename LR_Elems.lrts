//region LR_Elems (aka components in LR)
//region LR_Elems Sheet Items
function getSheetItem(sheet, item) { // returns sheet item elem
	debugFA("getSheetItem", arguments)
	return sheet.get(item)
}
//endregion

//region LR_Elems Events
const Evt_Click  = "click"
const Evt_Update = "update"
function onElemEvtFct(elem, evt, fct) {
	debugFA("onElemEvtFct", arguments)
	return elem.on(evt, fct)
}
function onElemClickFct(elem, fct) {
	debugFA("onElemClickFct", arguments)
	return onElemEvtFct(elem, Evt_Click, fct)
}
function onElemUpdateFct(elem, fct) {
	debugFA("onElemUpdateFct", arguments)
	return onElemEvtFct(elem, Evt_Update, fct)
}
function onElemChildEvtFct(elem, child, evt, fct) {
	debugFA("onElemChildEvtFct", arguments)
	return elem.on(evt, child, fct)
}
function onElemChildClickFct(elem, child, fct) {
	debugFA("onElemChildClickFct", arguments)
	return onElemChildEvtFct(elem, child, Evt_Click, fct)
}
function onElemChildUpdateFct(elem, child, fct) {
	debugFA("onElemChildUpdateFct", arguments)
	return onElemChildEvtFct(elem, child, Evt_Update, fct)
}
//endregion

//region LR_Elems Attributes
function getElemParent(elem) {
	debugFA("getElemParent", arguments)
	let result = null
	try { // skip error when no parent
		result = elem.parent()
	} catch {}
	return result
}
function getElemChild(elem, child) {
	debugFA("getElemChild", arguments)
	let result = null
	try { // skip error when no child
		result = elem.find(child)
	} catch {}
	return result
}
function getElemSheet(elem) {
	debugFA("getElemSheet", arguments)
	let result = null
	try { // skip error when no sheet
		result = elem.sheet()
	} catch {}
	return result
}
function getElemName(elem) {
	debugFA("getElemName", arguments)
	let result = null
	try { // skip error when no name
		result = elem.name()
	} catch {}
	return result
}
function getElemId(elem) {
	debugFA("getElemId", arguments)
	let result = null
	try { // skip error when no id
		result = elem.id()
	} catch {}
	return result
}
function getElemItem(elem) { // item is the id (aliases)
	debugFA("getElemItem", arguments)
	return getElemId(elem)
}
function getElemIndex(elem) {
	debugFA("getElemIndex", arguments)
	let result = null
	try { // skip error when no index
		result = elem.index()
	} catch {}
	return result
}
function getElemTypeof(elem) {
	debugFA("getElemTypeof", arguments)
	return typeof elem
}
function getElemChildren(elem) { // return children ids (get them with find)
	debugFA("getElemChildren", arguments)
	const elm_value = getElemValue(elem)
	if (notElem(elm_value)) {return Arr_None} // not an elem so no children
	return Object.keys(elm_value)
}
//endregion

//region LR_Elems Values
function getElemValue(elem) {
	debugFA("getElemValue", arguments)
	const elm_value = elem.value()
	return Number.isNaN(Number(elm_value)) ? // right type
		elm_value : Number(elm_value)
}
function setElemValue(elem, elm_value) {
	debugFA("setElemValue", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		setElemValue(elem, elm_value)
	})} // single elem from here
	elm_value = hasElemPlussigned(elem) // plussigned representation if any
	&& gthValue(elm_value, Int_Zero) ?
		pfxValue(elm_value, Str_Plus) : elm_value
	elem.value(elm_value)
	setElemDotted(elem) // dotted representation if any
	return elm_value
}
function rsaElemValue(elem, value_str, value_rpl) { // replace a string all
	debugFA("rsaElemValue", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		rsaElemValue(elem, value_str, value_rpl)
	})} // single elem from here
	const elm_value = rsaValue(getElemValue(elem), value_str, value_rpl)
	return setElemValue(elem, elm_value)
}
function hasElemValue(elem, elm_value) {
	debugFA("hasElemValue", arguments)
	return equValue(getElemValue(elem), elm_value)
}
function ysiElemValue(elem, value_str) { // if includes a string
	debugFA("ysiElemValue", arguments)
	return ysiValue(getElemValue(elem), value_str)
}
//endregion

//region LR_Elems Locked
const Str_Locked   = ":lock:"
const Str_Unlocked = ":lock-open:"
function setElemLocked(elem) {
	debugFA("setElemLocked", arguments)
	return setElemValue(elem, Str_Locked)
}
function setElemUnlocked(elem) {
	debugFA("setElemUnlocked", arguments)
	return setElemValue(elem, Str_Unlocked)
}
function togElemLocked(elem) {
	debugFA("togElemLocked", arguments)
	return hasElemLocked(elem) ?
		setElemUnlocked(elem) : setElemLocked(elem)
}
function hasElemLocked(elem) {
	debugFA("hasElemLocked", arguments)
	return hasElemValue(elem, Str_Locked)
}
//endregion

//region LR_Elems Folded
const Str_Folded   = ":sort-up:"
const Str_Unfolded = ":sort-down:"
function setElemFolded(elem) {
	debugFA("setElemFolded", arguments)
	return rsaElemValue(elem, Str_Unfolded, Str_Folded)
}
function setElemUnfolded(elem) {
	debugFA("setElemUnfolded", arguments)
	return rsaElemValue(elem, Str_Folded, Str_Unfolded)
}
function togElemFolded(elem) {
	debugFA("togElemFolded", arguments)
	return hasElemFolded(elem) ?
		setElemUnfolded(elem) : setElemFolded(elem)
}
function hasElemFolded(elem) {
	debugFA("hasElemFolded", arguments)
	return ysiElemValue(elem, Str_Folded)
}
//endregion

//region LR_Elems Tooltips
function setElemTooltip(elem, str_tooltip) {
	debugFA("setElemTooltip", arguments)
	try { // skip error when no tooltip
		elem.setToolTip(str_tooltip)
	} catch {}
	return str_tooltip
}
//endregion

//region LR_Elems Css Classes
const Css_DFlex			  = "d-flex" // add/remove for displayed on containers to work
const Css_WidgetContainer = "widget-container" // identify a container
const Css_DNone			  = "d-none"
const Css_Clickable		  = "clickable"
const Css_BgSecondary     = "bg-secondary"
const Css_Repeater        = "repeater"
const Css_RepeaterElement = "repeater-element"
function yesDFlexElem(elem) { // if require to add/rem dflex
	debugFA("yesDFlexElem", arguments)
	let result = hasElemCss(elem, Css_WidgetContainer)
	return result
}
function yesDFlexCss(css) { // if require to add/rem dflex
	debugFA("yesDFlexCss", arguments)
	let result = equValue(css, Css_DNone)
	return result
}
function yesDFlex(elem, css) { // if require to add/rem dflex
	debugFA("yesDFlex", arguments)
	let result = yesDFlexElem(elem) && yesDFlexCss(css)
	return result
}
function addElemCss(elem, css) { // multiple css allowed in one string
	debugFA("addElemCss", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		addElemCss(elem, css)
	})} // single elem from here
	css.split(Str_Space).forEach(function(css) {
		try { // skip error when no css classes
			if (yesDFlex(elem, css)) {
				elem.removeClass(Css_DFlex)
			}
			elem.addClass(css)
		} catch {}
	})
	return css
}
function remElemCss(elem, css) { // multiple css allowed in one string
	debugFA("remElemCss", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		remElemCss(elem, css)
	})} // single elem from here
	css.split(Str_Space).forEach(function(css) {
		try { // skip error when no css classes
			if (yesDFlex(elem, css)) {
				elem.addClass(Css_DFlex)
			}
			elem.removeClass(css)
		} catch {}
	})
	return css
}
function hasElemCss(elem, css) { // multiple css allowed in one string
	debugFA("hasElemCss", arguments)
	let result = true
	css.split(Str_Space).forEach(function(css) { // every css has to be present
		try { // skip error when no css classes
			if (! elem.hasClass(css)) {result = false}
		} catch {
			result = false
		}
	})
	return result
}
function getElemCss(elem) {
	debugFA("getElemCss", arguments)
	let result = Arr_None
	try { // skip error when no css classes
		result = elem.getClasses()
	} catch {}
	return result
}
//endregion

//region LR_Elems Cfk Classes
const Cfk_Effort      = "Cfk_Effort"		// has an effort related item
const Cfk_Dotted10    = "Cfk_Dotted10"		// has a dotted10 value representation
const Cfk_Plussigned  = "Cfk_Plussigned"	// allows to show "+" for positive values
const Cfk_Undisplayed = "Cfk_Undisplayed"	// allows to show/hide items
const Cfk_Clickable   = "Cfk_Clickable"		// allows to react to onclick
const Cfk_Modifiable  = "Cfk_Modifiable"	// allows only dec, inc
const Cfk_Selected    = "Cfk_Selected"		// allows only rej, inj
const Cfk_Fakeupdated = "Cfk_Fakeupdated"	// avoid computations propagation
const Key_CFKCSS      = { // relation between cfk and css /!\ space to separate
	Cfk_Effort        : Cfk_Effort      ,
	Cfk_Dotted10      : Cfk_Dotted10    ,
	Cfk_Plussigned    : Cfk_Plussigned  ,
	Cfk_Undisplayed   : Cfk_Undisplayed + Str_Space + Css_DNone,
	Cfk_Clickable     : Cfk_Clickable   + Str_Space + Css_Clickable,
	Cfk_Modifiable    : Cfk_Modifiable  ,
	Cfk_Selected      : Cfk_Selected    + Str_Space + Css_BgSecondary,
	Cfk_Fakeupdated   : Cfk_Fakeupdated ,
}
const Arr_THMCFK      = [ // cfk that support theme
	Cfk_Clickable,
	Cfk_Modifiable,
	Cfk_Selected,
]	
function yesCfkTheme(cfk) { // if cfk support theme
	debugFA("yesCfkTheme", arguments)
	return yaiValue(Arr_THMCFK, cfk)
}
function getElemCfkCss(elem, cfk) { // full corresponding css
	debugFA("getElemCfkCss", arguments)
	let result = Key_CFKCSS[cfk]
	if (yesCfkTheme(cfk)) { // add the elem sheet theme if any
		try { // skip error if any
			const elm_sheet = getElemSheet(elem)
			const prf_theme = getSheetThemePrf(elm_sheet)
			result = result + Str_Space + prf_theme
		} catch {}
	}
	return result
}
//endregion

//region LR_Elems Cfk Effort
function addElemEffort(elem) {
	debugFA("addElemEffort", arguments)
	return addElemCfk(elem, Cfk_Effort)			// normal operation
}
function remElemEffort(elem) {
	debugFA("remElemEffort", arguments)
	return remElemCfk(elem, Cfk_Effort)			// normal operation
}
function hasElemEffort(elem) {
	debugFA("hasElemEffort", arguments)
	return hasElemCfk(elem, Cfk_Effort)			// normal operation
}
//endregion

//region LR_Elems Cfk Dotted // Fakeupdate
function addElemDotted(elem, cfk_dotted) {
	debugFA("addElemDotted", arguments)
	addElemCfk(elem, cfk_dotted)				// normal operation
	return fakElemUpdate(elem)
}
function remElemDotted(elem, cfk_dotted) {
	debugFA("remElemDotted", arguments)
	remElemCfk(elem, cfk_dotted)				// normal operation
	return fakElemUpdate(elem)
}
function hasElemDotted(elem, cfk_dotted) {
	debugFA("hasElemDotted", arguments)
	return hasElemCfk(elem, cfk_dotted)			// normal operation
}
//region LR_Elems Cfk Dotted10
function addElemDotted10(elem) {
	debugFA("addElemDotted10", arguments)
	return addElemDotted(elem, Cfk_Dotted10)
}
function remElemDotted10(elem) {
	debugFA("remElemDotted10", arguments)
	return remElemDotted(elem, Cfk_Dotted10)
}
function hasElemDotted10(elem) {
	debugFA("hasElemDotted10", arguments)
	return hasElemCfk(elem, Cfk_Dotted10)
}
//endregion
//endregion

//region LR_Elems Cfk Plussigned // Fakeupdate
function addElemPlussigned(elem) {
	debugFA("addElemPlussigned", arguments)
	addElemCfk(elem, Cfk_Plussigned)			// normal operation
	return fakElemUpdate(elem)
}
function remElemPlussigned(elem) {
	debugFA("remElemPlussigned", arguments)
	remElemCfk(elem, Cfk_Plussigned)			// normal operation
	return fakElemUpdate(elem)
}
function hasElemPlussigned(elem) {
	debugFA("hasElemPlussigned", arguments)
	return hasElemCfk(elem, Cfk_Plussigned)		// normal operation
}
//endregion

//region LR_Elems Cfk Displayed
function addElemDisplayed(elem) {
	debugFA("addElemDisplayed", arguments)
	return remElemCfk(elem, Cfk_Undisplayed)	// reverse operation
}
function remElemDisplayed(elem) {
	debugFA("remElemDisplayed", arguments)
	return addElemCfk(elem, Cfk_Undisplayed)	// reverse operation
}
function hasElemDisplayed(elem) {
	debugFA("hasElemDisplayed", arguments)
	return ! hasElemCfk(elem, Cfk_Undisplayed)	// reverse operation
}
//endregion

//region LR_Elems Cfk Clickable
function addElemClickable(elem) {
	debugFA("addElemClickable", arguments)
	return addElemCfk(elem, Cfk_Clickable)		// normal operation
}
function remElemClickable(elem) {
	debugFA("remElemClickable", arguments)
	return remElemCfk(elem, Cfk_Clickable)		// normal operation
}
function hasElemClickable(elem) {
	debugFA("hasElemClickable", arguments)
	return hasElemCfk(elem, Cfk_Clickable)		// normal operation
}
//endregion

//region LR_Elems Cfk Modifiable // Fakeupdate
function addElemModifiable(elem) {
	debugFA("addElemModifiable", arguments)
	addElemCfk(elem, Cfk_Modifiable)			// normal operation
	return fakElemUpdate(elem)
}
function remElemModifiable(elem) {
	debugFA("remElemModifiable", arguments)
	remElemCfk(elem, Cfk_Modifiable)			// normal operation
	return fakElemUpdate(elem)
}
function hasElemModifiable(elem) {
	debugFA("hasElemModifiable", arguments)
	return hasElemCfk(elem, Cfk_Modifiable)		// normal operation
}
//endregion

//region LR_Elems Cfk Selected // Fakeupdate // Toggle Modifiable
function addElemSelected(elem) {
	debugFA("addElemSelected", arguments)
	remElemModifiable(elem)						// toggle modifiable/selected
	addElemCfk(elem, Cfk_Selected)				// normal operation
	return fakElemUpdate(elem)
}
function remElemSelected(elem) {
	debugFA("remElemSelected", arguments)
	addElemModifiable(elem)						// toggle modifiable/selected
	remElemCfk(elem, Cfk_Selected)				// normal operation
	return fakElemUpdate(elem)
}
function hasElemSelected(elem) {
	debugFA("hasElemSelected", arguments)
	return hasElemCfk(elem, Cfk_Selected)		// normal operation
}
//endregion

//region LR_Elems Cfk Fakeupdated
function addElemFakeupdated(elem) {
	debugFA("addElemFakeupdated", arguments)
	return addElemCfk(elem, Cfk_Fakeupdated)	// normal operation
}
function remElemFakeupdated(elem) {
	debugFA("remElemFakeupdated", arguments)
	return remElemCfk(elem, Cfk_Fakeupdated)	// normal operation
}
function hasElemFakeupdated(elem) {
	debugFA("hasElemFakeupdated", arguments)
	return hasElemCfk(elem, Cfk_Fakeupdated)	// normal operation
}
function fakElemUpdate(elem) {
	debugFA("fakElemUpdate", arguments)
	if (yesArray(elem)) {return elem.forEach(function(elem) { // recursive
		fakElemUpdate(elem)
	})} // single elem from here
	addElemFakeupdated(elem) // avoid computations propagation
	return setElemValue(elem, getElemValue(elem)) // provoke the fake update
}
//endregion

//region LR_Elems Related
function one2twoElem(elem, prefix_one, prefix_two) { // one related two elem
	debugFA("one2twoElem", arguments)
	try {
		const elm_sheet = getElemSheet(elem)
		const elm_item  = getElemItem(elem)
		const rel_item  = one2twoItem(elm_item, prefix_one, prefix_two)
		elem 			= getSheetItem(elm_sheet, rel_item)
	} catch {}
	return elem
}
function val2dotElem(elem) { // val related dot elem
	debugFA("val2dotElem", arguments)
	return one2twoElem(elem, Str_PFXVAL, Str_PFXDOT)
}
function val2effElem(elem) { // val related eff elem
	debugFA("val2effElem", arguments)
	return one2twoElem(elem, Str_PFXVAL, Str_PFXEFF)
}
function val2dxvElem(elem) { // val related dxv elem
	debugFA("val2dxvElem", arguments)
	return one2twoElem(elem, Str_PFXVAL, Str_PFXDXV)
}
function val2chkElem(elem) { // val related chk elem
	debugFA("val2chkElem", arguments)
	return one2twoElem(elem, Str_PFXVAL, Str_PFXCHK)
}
function chk2valElem(elem) { // chk related val elem
	debugFA("chk2valElem", arguments)
	return one2twoElem(elem, Str_PFXCHK, Str_PFXVAL)
}
//endregion

//region LR_Elems Repeaters
function rptElemDoIf(elem, _do_fct, _if_fct) { // apply fct on repeater if true
	debugFA("rptElemDoIf", arguments)
	if (arguments.length < 3) { // filter function
		_if_fct = function(elem) {
			debugFA("rptElemDoIf_if_fct", arguments)
			return true // true to do action function
		}
	}
	if (arguments.length < 2) { // action function
		_do_fct = function(elem) {
			debugFA("rptElemDoIf_do_fct", arguments)
			debugElem(elem, Yes_Debug, Yes_Indent)
			return true // true to continue recursive
		}
	}
	if (notElem(elem)) {return} // not an elem
	if (_if_fct(elem)) {
		// if (! _do_fct(elem)) {return} // /!\ repeat twice (why ?)
		const yes_recursive = _do_fct(elem)
		if (! yes_recursive) {return} // interrupt recursive 
	}
	// getElemChildren(elem).forEach(function(child) // /!\ repeat twice (why ?)
	const elm_children = getElemChildren(elem) 
	elm_children.forEach(function(child) { // recursive
		rptElemDoIf(getElemChild(elem, child), _do_fct, _if_fct)
	})
}
//endregion
//endregion
