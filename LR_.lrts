//region LR_ (LR Library)
//region LR_Constants
//region LR_Constants Values
const Int_Zero     = 0
const Str_None     = ""
const Arr_None     = []
const Obj_None     = {}
const Str_Space    = " "
const Str_Tab      = "\t"
const Str_Newline  = "\n"
const Str_SQMark   = "'"
const Str_DQMark   = '"'
const Str_OObject  = "{"
const Str_CObject  = "}"
const Str_OArray   = "["
const Str_CArray   = "]"
const Str_Comma    = ","
const Str_SDot     = "."
const Str_DDot     = ":"
const Infinity     = Number.MAX_SAFE_INTEGER
//endregion

//region LR_Constants Items Prefixes /!\ respect this convention for the code to work
const Str_PFXDXV = "DxV_" // dot and value item (container)
const Str_PFXVAL = "Val_" // value item
const Str_PFXDOT = "Dot_" // dot item
const Str_PFXEFF = "Eff_" // effort item
const Str_PFXMOD = "Mod_" // modifier item
const Str_PFXREP = "Rep_" // repeater item
const Str_PFXCHC = "Chc_" // choice item
const Str_PFXCHK = "Chk_" // checkbox item (can also be a label/icon etc)
const Str_PFXFLD = "Fld_" // foldering item (can also be a label/icon etc)
//endregion

//region LR_Constants DxV Display Modes
const Str_DXVDOT = "dots" // only dots
const Str_DXVVAL = "vals" // only values
const Str_DXVBTH = "both" // both of them
const Dft_DXVDFT = Str_DXVBTH
const Arr_DXVALW = [ // DxV allowed display modes
	Str_DXVDOT,
	Str_DXVVAL,
	Str_DXVBTH,
]
//endregion

//region LR_Constants Sheet Themes /!\ some items REQuired on sheets for theme to work on it
const REQ_THMOLD		= "REQ_THMOLD"		// previous theme (REQuired)
const REQ_THMPRF		= "REQ_THMPRF"		// choosen theme  (REQuired)
const Css_TextPrimary	= "text-primary"
const Css_TextSecondary	= "text-secondary"
const Css_TextSuccess	= "text-success"
const Css_TextDanger	= "text-danger"
const Css_TextWarning	= "text-warning"
const Css_TextInfo		= "text-info"
const Css_TextLight		= "text-light"
const Css_TextDark		= "text-dark"
const Css_TextMuted		= "text-muted"
const Css_TextWhite		= "text-white"
const Dft_THMDFT		= Css_TextWarning
const Arr_THMALW		= [ // Themes allowed
	Css_TextPrimary,
	Css_TextSecondary,
	Css_TextSuccess,
	Css_TextDanger,
	Css_TextWarning,
	Css_TextInfo,
	Css_TextLight,
	Css_TextDark,
	Css_TextMuted,
	Css_TextWhite,
]
//endregion
//endregion

//region LR_Debug
const Yes_Debug         = true
const Not_Debug         = false
const Dft_Debug         = Yes_Debug
const Dft_DebugFA       = Not_Debug
const Yes_Indent        = true
const Not_Indent        = false
const Dft_Indent        = Not_Indent
let   Key_DebugFAFctYes = { //relation between fct_name and debug // else Dft_DebugFA
}
function debug(str_debug, _yes_debug) {
	if (arguments.length < 2) {_yes_debug = Dft_Debug}
	if (_yes_debug) {log(str_debug)}
}
function debugOK(_yes_debug) {
	if (arguments.length < 1) {_yes_debug = Dft_Debug}
	debug("OK", _yes_debug)
}
function debugElem(elem, _yes_debug, _yes_indent) {
	if (arguments.length < 3) {_yes_indent = Dft_Indent}
	if (arguments.length < 2) {_yes_debug = Dft_Debug}
	if (! _yes_debug) {return} // force not debug
	debug("< ELEM >")
	debug("> parent: " + getElemParent(elem))
	debug("> parent id: " + getElemId(getElemParent(elem)))
	debug("> parent name: " + getElemName(getElemParent(elem)))
	debug("> sheet: " + getElemSheet(elem))
	debug("> sheet id: " + getElemId(getElemSheet(elem)))
	debug("> sheet name: " + getElemName(getElemSheet(elem)))
	debug("> id: " + getElemId(elem))
	debug("> name: " + getElemName(elem))
	debug("> index: " + getElemIndex(elem))
	debug("> typeof: " + getElemTypeof(elem))
	debug("> children: " + getElemChildren(elem))
	debug("> value: " + strThing(getElemValue(elem), _yes_indent))
	debug("> css: " + strThing(getElemCss(elem), _yes_indent))
}
function debugElemEvt(elem, evt) {
	debug("! on" + cpoValue(evt) + " " + getElemId(elem))
}
function debugElemClick(elem) {
	debugElemEvt(elem, Evt_Click)
}
function debugElemUpdate(elem) {
	debugElemEvt(elem, Evt_Update)
}
function debugFA(fct_name, _fct_args, _yes_debugfa) { // use: debugFA("myFct", arguments)
	if (arguments.length < 3) {_yes_debugfa = Dft_DebugFA}
	if (arguments.length < 2) {_fct_args = ""}
	_yes_debugfa = Key_DebugFAFctYes.hasOwnProperty(fct_name) ?
		Key_DebugFAFctYes[fct_name] : _yes_debugfa
	if (! _yes_debugfa) {return} // do not debug
	if (yesObject(_fct_args)) {
		if (yesArray(_fct_args)) {
			_fct_args = _fct_args.flat(Infinity)
		} else {
			_fct_args = Object.values(_fct_args)
		}
	}
	debug(fct_name + " " + _fct_args) // default debug mode
}
function debugFAOK(fct_name, _yes_debugfa) { // use: debugFAOK("myFunction")
	if (arguments.length < 2) {_yes_debugfa = Dft_DebugFA}
	debugFA(fct_name, "OK", _yes_debugfa)
}
//endregion

//region LR_Elems (aka components in LR)
//region LR_Elems Events
const Evt_Click  = "click"
const Evt_Update = "update"
function onElemEvtFct(elem, evt, fct) {
	debugFA("onElemEvtFct", arguments)
	return elem.on(evt, fct)
}
function onElemClickFct(elem, fct) {
	debugFA("onElemClickFct", arguments)
	return onElemEvtFct(elem, Evt_Click, fct)
}
function onElemUpdateFct(elem, fct) {
	debugFA("onElemUpdateFct", arguments)
	return onElemEvtFct(elem, Evt_Update, fct)
}
function onElemChildEvtFct(elem, child, evt, fct) {
	debugFA("onElemChildEvtFct", arguments)
	return elem.on(evt, child, fct)
}
function onElemChildClickFct(elem, child, fct) {
	debugFA("onElemChildClickFct", arguments)
	return onElemChildEvtFct(elem, child, Evt_Click, fct)
}
function onElemChildUpdateFct(elem, child, fct) {
	debugFA("onElemChildUpdateFct", arguments)
	return onElemChildEvtFct(elem, child, Evt_Update, fct)
}
//endregion

//region LR_Elems Attributes
function getElemParent(elem) {
	debugFA("getElemParent", arguments)
	let result = null
	try {result = elem.parent()} // skip error when no parent
	finally {}
	return result
}
function getElemChild(elem, child) {
	debugFA("getElemChild", arguments)
	let result = null
	try {result = elem.find(child)} // skip error when no child
	finally {}
	return result
}
function getElemSheet(elem) {
	debugFA("getElemSheet", arguments)
	let result = null
	try {result = elem.sheet()} // skip error when no sheet
	finally {}
	return result
}
function getElemName(elem) {
	debugFA("getElemName", arguments)
	let result = null
	try {result = elem.name()} // skip error when no name
	finally {}
	return result
}
function getElemId(elem) {
	debugFA("getElemId", arguments)
	let result = null
	try {result = elem.id()} // skip error when no id
	finally {}
	return result
}
function getElemIndex(elem) {
	debugFA("getElemIndex", arguments)
	let result = null
	try {result = elem.index()} // skip error when no index
	finally {}
	return result
}
function getElemTypeof(elem) {
	debugFA("getElemTypeof", arguments)
	return typeof elem
}
function getElemChildren(elem) { // return children ids (get them with find)
	debugFA("getElemChildren", arguments)
	const elm_value = getElemValue(elem)
	if (notElem(elm_value)) {return []} // not an elem so no children
	return Object.keys(elm_value)
}
//endregion

//region LR_Elems Values
function getElemValue(elem) {
	debugFA("getElemValue", arguments)
	const elm_value = elem.value()
	return Number.isNaN(Number(elm_value)) ? // right type
		elm_value : Number(elm_value)
}
//endregion

//region LR_Elems Classes
function getElemCss(elem) {
	debugFA("getElemCss", arguments)
	let result = []
	try {result = elem.getClasses()} // skip error when no classes
	finally {}
	return result
}
//endregion
//endregion

//region LR_Items (aka sheet ids in LR)
//region LR_Items Elems
function getSheetItem(sheet, item) { // returns sheet item elem
	debugFA("getSheetItem", arguments)
	return sheet.get(item)
}
//endregion
//endregion

//region LR_Operators
//region LR_Operators Random
function rndValue(value_min, value_max) { // random value (integer, inclusive)
	debugFA("rndValue", arguments)
	value_min = Math.ceil(value_min)
	value_max = Math.floor(value_max)
	return Math.floor(Math.random() * (value_max - value_min + 1) + value_min)
}
//endregion
//region LR_Operators Min/Max
function minValue(value_one, value_two) { // minimum value
	debugFA("minValue", arguments)
	return value_one < value_two ?
		value_one : value_two
}
function maxValue(value_one, value_two) { // maximum value
	debugFA("maxValue", arguments)
	return value_one > value_two ?
		value_one : value_two
}
//endregion
//region LR_Operators Mix
function mxlValue(value_one, value_two) { // minimum mix value
	debugFA("mxlValue", arguments)
	return Math.floor((value_one + value_two) / 2)
}
function mxhValue(value_one, value_two) { // maximum mix value
	debugFA("mxhValue", arguments)
	return Math.ceil((value_one + value_two) / 2)
}
//endregion
//region LR_Operators Compare
function equValue(value_one, value_two) { // if equal
	debugFA("equValue", arguments)
	return value_one == value_two
}
function neqValue(value_one, value_two) { // if not equal
	debugFA("neqValue", arguments)
	return value_one != value_two
}
function yesZero(value_one) { // if zero
	debugFA("yesZero", arguments)
	return equValue(value_one, Int_Zero)
}
function notZero(value_one) { // if not zero
	debugFA("notZero", arguments)
	return ! yesZero(value_one)
}
function yesStrNone(value_one) { // if none
	debugFA("yesStrNone", arguments)
	return equValue(value_one, Str_None)
}
function notStrNone(value_one) { // if not none
	debugFA("notStrNone", arguments)
	return ! yesStrNone(value_one)
}
function lthValue(value_one, value_two) { // if lower than
	debugFA("lthValue", arguments)
	return value_one <  value_two
}
function gthValue(value_one, value_two) { // if greater than
	debugFA("gthValue", arguments)
	return value_one >  value_two
}
function leqValue(value_one, value_two) { // if lower or equal
	debugFA("leqValue", arguments)
	return value_one <= value_two
}
function geqValue(value_one, value_two) { // if greater or equal
	debugFA("geqValue", arguments)
	return value_one >= value_two
}
//endregion
//region LR_Operators Include
function yisValue(value_one, value_str) { // if includes a string
	debugFA("yisValue", arguments)
	return value_one.includes(value_str)
}
function nisValue(value_one, value_str) { // if not includes a string
	debugFA("nisValue", arguments)
	return ! yisValue(value_one, value_str)
}
//endregion
//region LR_Operators Replace
function rsoValue(value_one, value_str, value_rpl) { // replace a string once
	debugFA("rsoValue", arguments)
	return value_one.replace(value_str, value_rpl)
}
function rsaValue(value_one, value_str, value_rpl) { // replace a string all
	debugFA("rsaValue", arguments)
	return value_one.replaceAll(value_str, value_rpl)
}
//endregion
//region LR_Operators Prefix/Suffix
function pfxValue(value_one, value_str) { // prefix with a string
	debugFA("pfxValue", arguments)
	return value_str + value_one
}
function sfxValue(value_one, value_str) { // suffix with a string
	debugFA("sfxValue", arguments)
	return value_one + value_str
}
//endregion
//region LR_Operators Enclose
function sqmValue(value_one) { // single quotes
	debugFA("sqmValue", arguments)
	return Str_SQMark + value_one + Str_SQMark
}
function dqmValue(value_one) { // double quotes
	debugFA("dqmValue", arguments)
	return Str_DQMark + value_one + Str_DQMark
}
//endregion
//region LR_Operators Cases
const Yes_FromLC        = true
const Not_FromLC        = false
const Dft_FromLC        = Not_FromLC
function lcaValue(value_one) { // lower case all
	debugFA("lcaValue", arguments)
	return value_one.toLowerCase()
}
function ucaValue(value_one) { // upper case all
	debugFA("ucaValue", arguments)
	return value_one.toUpperCase()
}
function cpoValue(value_one, _yes_fromlc) { // capitalize once
	debugFA("cpoValue", arguments)
	if (arguments.length < 2) {_yes_fromlc = Dft_FromLC}
	if (_yes_fromlc) {
		value_one = lcaValue(value_one)
	}
	return value_one.replace(/(^\w{1})|(\s+\w{1})/, function(letter) {
		return ucaValue(letter)
	})
}
function cpaValue(value_one, _yes_fromlc) { // capitalize all
	debugFA("cpaValue", arguments)
	if (arguments.length < 2) {_yes_fromlc = Dft_FromLC}
	if (_yes_fromlc) {
		value_one = lcaValue(value_one)
	}
	return value_one.replace(/(^\w{1})|(\s+\w{1})/g, function(letter) {
		return ucaValue(letter)
	})
}
//endregion
//region LR_Operators Toggle
function tynValue(value_one) { // toggle yes/not (1/0)
	debugFA("tynValue", arguments)
	return value_one ?
		0 : 1
}
//endregion
//region LR_Operators Stringify
function strThing(thing, _yes_indent, _str_indentcur, _str_indentuse) { // thing as a string
	debugFA("strThing", arguments)
	if (arguments.length < 4) {_str_indentuse = Str_Tab} // indentation string
	if (arguments.length < 3) {_str_indentcur = Str_None} // current indentation
	if (arguments.length < 2) {_yes_indent = Dft_Indent}
	const str_newline = _yes_indent ? // no newline if no indentation
		Str_Newline : Str_None
	_str_indentcur = _yes_indent ? // clear _str_indentcur if no indentation
		_str_indentcur : Str_None
	const str_indentnxt = _yes_indent ? // for the next indentation
		_str_indentcur + _str_indentuse : Str_None
	let result = Str_None
	let obj_result = Str_None // result of an object entries
	let itm_result = Str_None // result of an object entry
	if (yesObject(thing)) {
		if (yesNull(thing)) { // null
			result = Str_Null
		} else if (yesArray(thing)) { // array
			result = sfxValue(result, Str_OArray)
			thing.forEach(function(itm) { // recursive
				itm_result = strThing(itm, _yes_indent, str_indentnxt, _str_indentuse)
				if (notStrNone(itm_result)) {
					obj_result = obj_result + str_newline + str_indentnxt + itm_result + Str_Comma + Str_Space
				}
			})
			if (notStrNone(obj_result)) {
				result = result + _str_indentcur + obj_result + str_newline + _str_indentcur
			}
			result = sfxValue(result, Str_CArray)
		} else { // object
			result = sfxValue(result, Str_OObject)
			Object.keys(thing).forEach(function(key) { // recursive
				itm_result = dqmValue(key) + Str_DDot + Str_Space
				itm_result = itm_result + strThing(thing[key], _yes_indent, str_indentnxt, _str_indentuse)
				if (notStrNone(itm_result)) {
					obj_result = obj_result + str_newline + str_indentnxt + itm_result + Str_Comma + Str_Space
				}
			})
			if (notStrNone(obj_result)) {
				result = result + _str_indentcur + obj_result + str_newline + _str_indentcur
			}
			result = sfxValue(result, Str_CObject)
		}
	} else {
		if (yesString(thing)) {
			result = dqmValue(thing)
		} else if (yesUndefined(thing)) {
			result = Str_Undefined
		} else {
			result = thing
		}
	}
	return result
}
//endregion
//region LR_Operators Convert
function val2dotItem(item) { // related dot item
	debugFA("val2dotItem", arguments)
	return rsoValue(item, Str_PFXVAL, Str_PFXDOT)
}
function val2effItem(item) { // related eff item
	debugFA("val2effItem", arguments)
	return rsoValue(item, Str_PFXVAL, Str_PFXEFF)
}
function val2dxvItem(item) { // related dxv item
	debugFA("val2dxvItem", arguments)
	return rsoValue(item, Str_PFXVAL, Str_PFXDXV)
}
function val2chkItem(item) { // related chk item
	debugFA("val2chkItem", arguments)
	return rsoValue(item, Str_PFXVAL, Str_PFXCHK)
}
function chk2valItem(item) { // related val item
	debugFA("chk2valItem", arguments)
	return rsoValue(item, Str_PFXCHK, Str_PFXVAL)
}
//endregion
//endregion

//region LR_Types
const Str_Null		= "null"
const Str_Undefined	= "undefined"
const Str_String	= "string"
const Str_Thing	    = "thing"
const Str_Object	= "object"
const Str_Array	    = "array"
const Str_Elem	    = "elem"
function yesNull(thing) {
	return thing === null
}
function notNull(thing) {
	return ! yesNull(thing)
}
function yesUndefined(thing) {
	return typeof thing === Str_Undefined
}
function notUndefined(thing) {
	return ! yesUndefined(thing)
}
function yesString(thing) {
	return typeof thing === Str_String
}
function notString(thing) {
	return ! yesString(thing)
}
function yesThing(thing) {
	return notNull(thing) && notUndefined(thing)
}
function notThing(thing) {
	return ! yesThing(thing)
}
function yesObject(thing) {
	return yesThing(thing) && typeof thing === Str_Object
}
function notObject(thing) {
	return ! yesObject(thing)
}
function yesArray(thing) {
	return yesThing(thing) && Array.isArray(thing)
}
function notArray(thing) {
	return ! yesArray(thing)
}
function yesElem(thing) {
	return yesObject(thing) && notArray(thing)
}
function notElem(thing) {
	return ! yesElem(thing)
}
//endregion
//endregion
