//region LR_Operators
//region LR_Operators Random
function rndValue(value_min, value_max) { // random value (integer, inclusive)
	debugFA("rndValue", arguments)
	value_min = Math.ceil(value_min)
	value_max = Math.floor(value_max)
	return Math.floor(Math.random() * (value_max - value_min + 1) + value_min)
}
//endregion

//region LR_Operators Min/Max
function minValue(value_one, value_two) { // minimum value
	debugFA("minValue", arguments)
	return value_one < value_two ?
		value_one : value_two
}
function maxValue(value_one, value_two) { // maximum value
	debugFA("maxValue", arguments)
	return value_one > value_two ?
		value_one : value_two
}
//endregion

//region LR_Operators Mix
function mxlValue(value_one, value_two) { // minimum mix value
	debugFA("mxlValue", arguments)
	return Math.floor((value_one + value_two) / 2)
}
function mxhValue(value_one, value_two) { // maximum mix value
	debugFA("mxhValue", arguments)
	return Math.ceil((value_one + value_two) / 2)
}
//endregion

//region LR_Operators Compare
function equValue(value_one, value_two) { // if equal
	debugFA("equValue", arguments)
	return value_one === value_two
}
function neqValue(value_one, value_two) { // if not equal
	debugFA("neqValue", arguments)
	return value_one !== value_two
}
function yesZero(value_one) { // if zero
	debugFA("yesZero", arguments)
	return equValue(value_one, Int_Zero)
}
function notZero(value_one) { // if not zero
	debugFA("notZero", arguments)
	return ! yesZero(value_one)
}
function yesStrNone(value_one) { // if none
	debugFA("yesStrNone", arguments)
	return equValue(value_one, Str_None)
}
function notStrNone(value_one) { // if not none
	debugFA("notStrNone", arguments)
	return ! yesStrNone(value_one)
}
function yesArrNone(value_one) { // if none
	debugFA("yesArrNone", arguments)
	return equValue(value_one, Arr_None)
}
function notArrNone(value_one) { // if not none
	debugFA("notArrNone", arguments)
	return ! yesArrNone(value_one)
}
function yesObjNone(value_one) { // if none
	debugFA("yesObjNone", arguments)
	return equValue(value_one, Obj_None)
}
function notObjNone(value_one) { // if not none
	debugFA("notObjNone", arguments)
	return ! yesObjNone(value_one)
}
function lthValue(value_one, value_two) { // if lower than
	debugFA("lthValue", arguments)
	return value_one <  value_two
}
function gthValue(value_one, value_two) { // if greater than
	debugFA("gthValue", arguments)
	return value_one >  value_two
}
function leqValue(value_one, value_two) { // if lower or equal
	debugFA("leqValue", arguments)
	return value_one <= value_two
}
function geqValue(value_one, value_two) { // if greater or equal
	debugFA("geqValue", arguments)
	return value_one >= value_two
}
//endregion

//region LR_Operators Includes
function ysiValue(str_value, value_one) { // if string includes
	debugFA("ysiValue", arguments)
	return str_value.includes(value_one)
}
function nsiValue(str_value, value_one) { // if not string includes
	debugFA("nsiValue", arguments)
	return ! ysiValue(str_value, value_one)
}
function yaiValue(arr_value, value_one) { // if array includes
	debugFA("yaiValue", arguments)
	return arr_value.includes(value_one)
}
function naiValue(arr_value, value_one) { // if not array includes
	debugFA("naiValue", arguments)
	return ! yaiValue(arr_value, value_one)
}
function ykiValue(obj_value, value_one) { // if object includes key
	debugFA("ykiValue", arguments)
	return arr_value.hasOwnProperty(value_one)
}
function nkiValue(obj_value, value_one) { // if not object includes key
	debugFA("nkiValue", arguments)
	return ! ykiValue(arr_value, value_one)
}
//endregion

//region LR_Operators Replace
function rsoValue(str_value, value_one, value_two) { // replace a string once
	debugFA("rsoValue", arguments)
	return str_value.replace(value_one, value_two)
}
function rsaValue(str_value, value_one, value_two) { // replace a string all
	debugFA("rsaValue", arguments)
	return str_value.replaceAll(value_one, value_two)
}
//endregion

//region LR_Operators Prefix/Suffix
function pfxValue(value_one, value_str) { // prefix with a string
	debugFA("pfxValue", arguments)
	return value_str + value_one
}
function sfxValue(value_one, value_str) { // suffix with a string
	debugFA("sfxValue", arguments)
	return value_one + value_str
}
//endregion

//region LR_Operators Enclose
function sqmValue(value_one) { // single quotes
	debugFA("sqmValue", arguments)
	return Str_SQMark + value_one + Str_SQMark
}
function dqmValue(value_one) { // double quotes
	debugFA("dqmValue", arguments)
	return Str_DQMark + value_one + Str_DQMark
}
//endregion

//region LR_Operators Cases
const Yes_FromLC        = true
const Not_FromLC        = false
const Dft_FromLC        = Not_FromLC
function lcaValue(value_one) { // lower case all
	debugFA("lcaValue", arguments)
	return value_one.toLowerCase()
}
function ucaValue(value_one) { // upper case all
	debugFA("ucaValue", arguments)
	return value_one.toUpperCase()
}
function cpoValue(value_one, _yes_fromlc) { // capitalize once
	debugFA("cpoValue", arguments)
	if (arguments.length < 2) {_yes_fromlc = Dft_FromLC}
	if (_yes_fromlc) {
		value_one = lcaValue(value_one)
	}
	return value_one.replace(/(^\w{1})|(\s+\w{1})/, function(letter) {
		return ucaValue(letter)
	})
}
function cpaValue(value_one, _yes_fromlc) { // capitalize all
	debugFA("cpaValue", arguments)
	if (arguments.length < 2) {_yes_fromlc = Dft_FromLC}
	if (_yes_fromlc) {
		value_one = lcaValue(value_one)
	}
	return value_one.replace(/(^\w{1})|(\s+\w{1})/g, function(letter) {
		return ucaValue(letter)
	})
}
//endregion

//region LR_Operators Toggle
function tynValue(value_one) { // toggle yes/not (1/0)
	debugFA("tynValue", arguments)
	return value_one ?
		0 : 1
}
//endregion

//region LR_Operators Stringify
function strThing(thing, _yes_indent, _str_indentcur, _str_indentuse) { // thing as a string
	debugFA("strThing", arguments)
	if (arguments.length < 4) {_str_indentuse = Str_Tab} // indentation string
	if (arguments.length < 3) {_str_indentcur = Str_None} // current indentation
	if (arguments.length < 2) {_yes_indent = Dft_Indent}
	const str_newline = _yes_indent ? // no newline if no indentation
		Str_Newline : Str_None
	_str_indentcur = _yes_indent ? // clear _str_indentcur if no indentation
		_str_indentcur : Str_None
	const str_indentnxt = _yes_indent ? // for the next indentation
		_str_indentcur + _str_indentuse : Str_None
	let result = Str_None
	let obj_result = Str_None // result of an object entries
	let itm_result = Str_None // result of an object entry
	if (yesObject(thing)) {
		if (yesNull(thing)) { // null
			result = Str_Null
		} else if (yesArray(thing)) { // array
			result = sfxValue(result, Str_OArray)
			thing.forEach(function(itm) { // recursive
				itm_result = strThing(itm, _yes_indent, str_indentnxt, _str_indentuse)
				if (notStrNone(itm_result)) {
					obj_result = obj_result + str_newline + str_indentnxt + itm_result + Str_Comma + Str_Space
				}
			})
			if (notStrNone(obj_result)) {
				result = result + _str_indentcur + obj_result + str_newline + _str_indentcur
			}
			result = sfxValue(result, Str_CArray)
		} else { // object
			result = sfxValue(result, Str_OObject)
			Object.keys(thing).forEach(function(key) { // recursive
				itm_result = dqmValue(key) + Str_DDot + Str_Space
				itm_result = itm_result + strThing(thing[key], _yes_indent, str_indentnxt, _str_indentuse)
				if (notStrNone(itm_result)) {
					obj_result = obj_result + str_newline + str_indentnxt + itm_result + Str_Comma + Str_Space
				}
			})
			if (notStrNone(obj_result)) {
				result = result + _str_indentcur + obj_result + str_newline + _str_indentcur
			}
			result = sfxValue(result, Str_CObject)
		}
	} else {
		if (yesString(thing)) {
			result = dqmValue(thing)
		} else if (yesUndefined(thing)) {
			result = Str_Undefined
		} else {
			result = thing
		}
	}
	return result
}
//endregion

//region LR_Operators Related
function one2twoItem(item, prefix_one, prefix_two) { // one related two item
	debugFA("one2twoItem", arguments)
	return rsoValue(item, prefix_one, prefix_two)
}
function val2dotItem(item) { // val related dot item
	debugFA("val2dotItem", arguments)
	return one2twoItem(item, Str_PFXVAL, Str_PFXDOT)
}
function val2effItem(item) { // val related eff item
	debugFA("val2effItem", arguments)
	return one2twoItem(item, Str_PFXVAL, Str_PFXEFF)
}
function val2dxvItem(item) { // val related dxv item
	debugFA("val2dxvItem", arguments)
	return one2twoItem(item, Str_PFXVAL, Str_PFXDXV)
}
function val2chkItem(item) { // val related chk item
	debugFA("val2chkItem", arguments)
	return one2twoItem(item, Str_PFXVAL, Str_PFXCHK)
}
function chk2valItem(item) { // chk related val item
	debugFA("chk2valItem", arguments)
	return one2twoItem(item, Str_PFXCHK, Str_PFXVAL)
}
//endregion
//endregion
