//region LR_Constants
//region LR_Constants Values
const Int_Zero     = 0
const Int_POne     = +1
const Int_MOne     = -1
const Str_Zero     = "0"
const Str_None     = ""
const Arr_None     = []
const Obj_None     = {}
const Str_Space    = " "
const Str_Tab      = "\t"
const Str_Newline  = "\n"
const Str_SQMark   = "'"
const Str_DQMark   = '"'
const Str_OObject  = "{"
const Str_CObject  = "}"
const Str_OArray   = "["
const Str_CArray   = "]"
const Str_Comma    = ","
const Str_SDot     = "."
const Str_DDot     = ":"
const Str_Plus     = "+"
const Str_Minus    = "-"
const Infinity     = Number.MAX_SAFE_INTEGER
//endregion

//region LR_Constants Items Prefixes /!\ respect this convention for the code to work
const Str_PFXDXV = "DxV_" // dot and value item (container)
const Str_PFXVAL = "Val_" // value item
const Str_PFXDOT = "Dot_" // dot item
const Str_PFXEFF = "Eff_" // effort item
const Str_PFXMOD = "Mod_" // modifier item
const Str_PFXREP = "Rep_" // repeater item
const Str_PFXCHC = "Chc_" // choice item
const Str_PFXCHK = "Chk_" // checkbox item (can also be a label/icon etc)
const Str_PFXFLD = "Fld_" // foldering item (can also be a label/icon etc)
//endregion

//region LR_Constants DxV Display Modes
const Str_DXVDOT = "dots" // only dots
const Str_DXVVAL = "vals" // only values
const Str_DXVBTH = "both" // both of them
const Dft_DXVDFT = Str_DXVBTH
const Arr_DXVALW = [ // DxV allowed display modes
	Str_DXVDOT,
	Str_DXVVAL,
	Str_DXVBTH,
]
//endregion

//region LR_Constants Sheet Themes /!\ some items REQuired on sheets for theme to work on it
const REQ_THMOLD		= "REQ_THMOLD"		// previous theme item (REQuired)
const REQ_THMPRF		= "REQ_THMPRF"		// choosen theme item  (REQuired)
const Css_TextPrimary	= "text-primary"
const Css_TextSecondary	= "text-secondary"
const Css_TextSuccess	= "text-success"
const Css_TextDanger	= "text-danger"
const Css_TextWarning	= "text-warning"
const Css_TextInfo		= "text-info"
const Css_TextLight		= "text-light"
const Css_TextDark		= "text-dark"
const Css_TextMuted		= "text-muted"
const Css_TextWhite		= "text-white"
const Dft_THMDFT		= Css_TextWarning
const Arr_THMALW		= [ // themes allowed
	Css_TextPrimary,
	Css_TextSecondary,
	Css_TextSuccess,
	Css_TextDanger,
	Css_TextWarning,
	Css_TextInfo,
	Css_TextLight,
	Css_TextDark,
	Css_TextMuted,
	Css_TextWhite,
]
//endregion
//endregion

//region LR_Debug
const Yes_Debug   = true
const Not_Debug   = false
const Dft_Debug   = Yes_Debug
const Dft_DebugFA = Not_Debug
const Yes_Indent  = true
const Not_Indent  = false
const Dft_Indent  = Not_Indent
let   Key_DEBUGFA = { //relation between fct_name and debug // else Dft_DebugFA
}
function debug(str_debug, _yes_debug) {
	if (arguments.length < 2) {_yes_debug = Dft_Debug}
	if (_yes_debug) {log(str_debug)}
}
function debugOK(_yes_debug) {
	if (arguments.length < 1) {_yes_debug = Dft_Debug}
	debug("OK", _yes_debug)
}
function debugElem(elem, _yes_debug, _yes_indent) {
	if (arguments.length < 3) {_yes_indent = Dft_Indent}
	if (arguments.length < 2) {_yes_debug = Dft_Debug}
	if (! _yes_debug) {return} // force not debug
	debug("< ELEM >")
	debug("> parent: " + getElemParent(elem))
	debug("> parent id: " + getElemId(getElemParent(elem)))
	debug("> parent name: " + getElemName(getElemParent(elem)))
	debug("> sheet: " + getElemSheet(elem))
	debug("> sheet id: " + getElemId(getElemSheet(elem)))
	debug("> sheet name: " + getElemName(getElemSheet(elem)))
	debug("> id: " + getElemId(elem))
	debug("> name: " + getElemName(elem))
	debug("> index: " + getElemIndex(elem))
	debug("> typeof: " + getElemTypeof(elem))
	debug("> children: " + getElemChildren(elem))
	debug("> value: " + strThing(getElemValue(elem), _yes_indent))
	debug("> css: " + strThing(getElemCss(elem), _yes_indent))
}
function debugElemEvt(elem, evt) {
	debug("! on" + cpoValue(evt) + " " + getElemId(elem))
}
function debugElemClick(elem) {
	debugElemEvt(elem, Evt_Click)
}
function debugElemUpdate(elem) {
	debugElemEvt(elem, Evt_Update)
}
function debugFA(fct_name, _fct_args, _yes_debugfa) { // debugFA("myFct", arguments)
	if (arguments.length < 3) {_yes_debugfa = Dft_DebugFA}
	if (arguments.length < 2) {_fct_args = ""}
	_yes_debugfa = Key_DEBUGFA.hasOwnProperty(fct_name) ? // /!\ avoid dead loop
		Key_DEBUGFA[fct_name] : _yes_debugfa
	if (! _yes_debugfa) {return} // do not debug
	if (yesObject(_fct_args)) {
		if (yesArray(_fct_args)) {
			_fct_args = _fct_args.flat(Infinity)
		} else {
			_fct_args = Object.values(_fct_args)
		}
	}
	debug(fct_name + " " + _fct_args) // default debug mode
}
function debugFAOK(fct_name, _yes_debugfa) { // use: debugFAOK("myFunction")
	if (arguments.length < 2) {_yes_debugfa = Dft_DebugFA}
	debugFA(fct_name, "OK", _yes_debugfa)
}
//endregion

//region LR_Operators
//region LR_Operators Random
function rndValue(value_min, value_max) { // random value (integer, inclusive)
	debugFA("rndValue", arguments)
	value_min = Math.ceil(value_min)
	value_max = Math.floor(value_max)
	return Math.floor(Math.random() * (value_max - value_min + 1) + value_min)
}
//endregion

//region LR_Operators Min/Max
function minValue(value_one, value_two) { // minimum value
	debugFA("minValue", arguments)
	return value_one < value_two ?
		value_one : value_two
}
function maxValue(value_one, value_two) { // maximum value
	debugFA("maxValue", arguments)
	return value_one > value_two ?
		value_one : value_two
}
//endregion

//region LR_Operators Mix
function mxlValue(value_one, value_two) { // minimum mix value
	debugFA("mxlValue", arguments)
	return Math.floor((value_one + value_two) / 2)
}
function mxhValue(value_one, value_two) { // maximum mix value
	debugFA("mxhValue", arguments)
	return Math.ceil((value_one + value_two) / 2)
}
//endregion

//region LR_Operators Compare
function yeqValue(value_one, value_two) { // if equal
	debugFA("yeqValue", arguments)
	return value_one === value_two
}
function neqValue(value_one, value_two) { // if not equal
	debugFA("neqValue", arguments)
	return ! yeqValue(value_one, value_two)
}
function yizValue(value_one) { // if int zero
	debugFA("yizValue", arguments)
	return yeqValue(value_one, Int_Zero)
}
function yzpValue(value_one) { // if int zero positive
	debugFA("yzpValue", arguments)
	return ygeValue(value_one, Int_Zero)
}
function yppValue(value_one) { // if int pure positive
	debugFA("yppValue", arguments)
	return ygtValue(value_one, Int_Zero)
}
function yznValue(value_one) { // if int zero negative
	debugFA("yznValue", arguments)
	return yleValue(value_one, Int_Zero)
}
function ypnValue(value_one) { // if int pure negative
	debugFA("ypnValue", arguments)
	return yltValue(value_one, Int_Zero)
}
function nizValue(value_one) { // if not int zero
	debugFA("nizValue", arguments)
	return ! yizValue(value_one)
}
function ysnValue(value_one) { // if string none
	debugFA("ysnValue", arguments)
	return yeqValue(value_one, Str_None)
}
function nsnValue(value_one) { // if not string none
	debugFA("nsnValue", arguments)
	return ! ysnValue(value_one)
}
function yanValue(value_one) { // if array none
	debugFA("yanValue", arguments)
	return yeqValue(value_one, Arr_None)
}
function nanValue(value_one) { // if not array none
	debugFA("nanValue", arguments)
	return ! yanValue(value_one)
}
function yonValue(value_one) { // if object none
	debugFA("yonValue", arguments)
	return yeqValue(value_one, Obj_None)
}
function nonValue(value_one) { // if not object none
	debugFA("nonValue", arguments)
	return ! yonValue(value_one)
}
function yltValue(value_one, value_two) { // if lower than
	debugFA("yltValue", arguments)
	return value_one <  value_two
}
function ygtValue(value_one, value_two) { // if greater than
	debugFA("ygtValue", arguments)
	return value_one >  value_two
}
function yleValue(value_one, value_two) { // if lower or equal
	debugFA("yleValue", arguments)
	return value_one <= value_two
}
function ygeValue(value_one, value_two) { // if greater or equal
	debugFA("ygeValue", arguments)
	return value_one >= value_two
}
//endregion

//region LR_Operators Includes
function ysiValue(str_value, value_one) { // if string includes
	debugFA("ysiValue", arguments)
	return str_value.includes(value_one)
}
function nsiValue(str_value, value_one) { // if not string includes
	debugFA("nsiValue", arguments)
	return ! ysiValue(str_value, value_one)
}
function yaiValue(arr_value, value_one) { // if array includes
	debugFA("yaiValue", arguments)
	return arr_value.includes(value_one)
}
function naiValue(arr_value, value_one) { // if not array includes
	debugFA("naiValue", arguments)
	return ! yaiValue(arr_value, value_one)
}
function ykiValue(obj_value, value_one) { // if object includes key
	debugFA("ykiValue", arguments)
	return arr_value.hasOwnProperty(value_one)
}
function nkiValue(obj_value, value_one) { // if not object includes key
	debugFA("nkiValue", arguments)
	return ! ykiValue(arr_value, value_one)
}
//endregion

//region LR_Operators Replace
function rsoValue(str_value, value_one, value_two) { // replace a string once
	debugFA("rsoValue", arguments)
	return str_value.replace(value_one, value_two)
}
function rsaValue(str_value, value_one, value_two) { // replace a string all
	debugFA("rsaValue", arguments)
	return str_value.replaceAll(value_one, value_two)
}
//endregion

//region LR_Operators Generate
function gaiValue(_int_from, _int_lenght, _int_step) { // generate array of int
	debugFA("gaiValue", arguments)
	try {tryArg(_int_from)}   catch(e) {_int_from   = Int_Zero}
	try {tryArg(_int_lenght)} catch(e) {_int_lenght = Int_POne}
	try {tryArg(_int_step)}   catch(e) {_int_step   = Int_POne}
	let result = []
	while (yppValue(_int_lenght)) {
		result.push(_int_from)
		_int_from   += _int_step
		_int_lenght -= Int_POne
	}
	return result
}
//endregion

//region LR_Operators Prefix/Suffix
function pfxValue(value_one, value_str) { // prefix with a string
	debugFA("pfxValue", arguments)
	return value_str + value_one
}
function sfxValue(value_one, value_str) { // suffix with a string
	debugFA("sfxValue", arguments)
	return value_one + value_str
}
//endregion

//region LR_Operators Enclose
function sqmValue(value_one) { // single quotes
	debugFA("sqmValue", arguments)
	return Str_SQMark + value_one + Str_SQMark
}
function dqmValue(value_one) { // double quotes
	debugFA("dqmValue", arguments)
	return Str_DQMark + value_one + Str_DQMark
}
//endregion

//region LR_Operators Cases
const Yes_FromLC        = true
const Not_FromLC        = false
const Dft_FromLC        = Not_FromLC
function lcaValue(value_one) { // lower case all
	debugFA("lcaValue", arguments)
	return value_one.toLowerCase()
}
function ucaValue(value_one) { // upper case all
	debugFA("ucaValue", arguments)
	return value_one.toUpperCase()
}
function cpoValue(value_one, _yes_fromlc) { // capitalize once
	debugFA("cpoValue", arguments)
	if (arguments.length < 2) {_yes_fromlc = Dft_FromLC}
	if (_yes_fromlc) {
		value_one = lcaValue(value_one)
	}
	return value_one.replace(/(^\w{1})|(\s+\w{1})/, function(letter) {
		return ucaValue(letter)
	})
}
function cpaValue(value_one, _yes_fromlc) { // capitalize all
	debugFA("cpaValue", arguments)
	if (arguments.length < 2) {_yes_fromlc = Dft_FromLC}
	if (_yes_fromlc) {
		value_one = lcaValue(value_one)
	}
	return value_one.replace(/(^\w{1})|(\s+\w{1})/g, function(letter) {
		return ucaValue(letter)
	})
}
//endregion

//region LR_Operators Toggle
function tynValue(value_one) { // toggle yes/not (1/0)
	debugFA("tynValue", arguments)
	return value_one ?
		0 : 1
}
//endregion

//region LR_Operators Stringify
function strThing(thing, _yes_indent, _str_indentcur, _str_indentuse) { // str a thing
	debugFA("strThing", arguments)
	if (arguments.length < 4) {_str_indentuse = Str_Tab} // indentation string
	if (arguments.length < 3) {_str_indentcur = Str_None} // current indentation
	if (arguments.length < 2) {_yes_indent = Dft_Indent}
	const str_newline = _yes_indent ? // no newline if no indentation
		Str_Newline : Str_None
	_str_indentcur = _yes_indent ? // clear _str_indentcur if no indentation
		_str_indentcur : Str_None
	const str_indentnxt = _yes_indent ? // for the next indentation
		_str_indentcur + _str_indentuse : Str_None
	let result = Str_None
	let obj_result = Str_None // result of an object entries
	let itm_result = Str_None // result of an object entry
	if (yesObject(thing)) {
		if (yesNull(thing)) { // null
			result = Str_Null
		} else if (yesArray(thing)) { // array
			result = sfxValue(result, Str_OArray)
			thing.forEach(function(itm) { // recursive
				itm_result = strThing(itm, _yes_indent, str_indentnxt, _str_indentuse)
				if (nsnValue(itm_result)) {
					obj_result = obj_result + str_newline + str_indentnxt + itm_result + Str_Comma + Str_Space
				}
			})
			if (nsnValue(obj_result)) {
				result = result + _str_indentcur + obj_result + str_newline + _str_indentcur
			}
			result = sfxValue(result, Str_CArray)
		} else { // object
			result = sfxValue(result, Str_OObject)
			Object.keys(thing).forEach(function(key) { // recursive
				itm_result = dqmValue(key) + Str_DDot + Str_Space
				itm_result = itm_result + strThing(thing[key], _yes_indent, str_indentnxt, _str_indentuse)
				if (nsnValue(itm_result)) {
					obj_result = obj_result + str_newline + str_indentnxt + itm_result + Str_Comma + Str_Space
				}
			})
			if (nsnValue(obj_result)) {
				result = result + _str_indentcur + obj_result + str_newline + _str_indentcur
			}
			result = sfxValue(result, Str_CObject)
		}
	} else {
		if (yesString(thing)) {
			result = dqmValue(thing)
		} else if (yesUndefined(thing)) {
			result = Str_Undefined
		} else {
			result = thing
		}
	}
	return result
}
//endregion

//region LR_Operators Related
function one2twoItem(item, prefix_one, prefix_two) { // one related two item
	debugFA("one2twoItem", arguments)
	return rsoValue(item, prefix_one, prefix_two)
}
function val2dotItem(item) { // val related dot item
	debugFA("val2dotItem", arguments)
	return one2twoItem(item, Str_PFXVAL, Str_PFXDOT)
}
function val2effItem(item) { // val related eff item
	debugFA("val2effItem", arguments)
	return one2twoItem(item, Str_PFXVAL, Str_PFXEFF)
}
function val2dxvItem(item) { // val related dxv item
	debugFA("val2dxvItem", arguments)
	return one2twoItem(item, Str_PFXVAL, Str_PFXDXV)
}
function val2chkItem(item) { // val related chk item
	debugFA("val2chkItem", arguments)
	return one2twoItem(item, Str_PFXVAL, Str_PFXCHK)
}
function chk2valItem(item) { // chk related val item
	debugFA("chk2valItem", arguments)
	return one2twoItem(item, Str_PFXCHK, Str_PFXVAL)
}
//endregion
//endregion

//region LR_Types
const Str_Null		= "null"
const Str_Undefined	= "undefined"
const Str_String	= "string"
const Str_Thing	    = "thing"
const Str_Object	= "object"
const Str_Array	    = "array"
const Str_Elem	    = "elem"
function yesNull(thing) {
	return thing === null
}
function notNull(thing) {
	return ! yesNull(thing)
}
function yesUndefined(thing) {
	return typeof thing === Str_Undefined
}
function notUndefined(thing) {
	return ! yesUndefined(thing)
}
function yesString(thing) {
	return typeof thing === Str_String
}
function notString(thing) {
	return ! yesString(thing)
}
function yesThing(thing) {
	return notNull(thing) && notUndefined(thing)
}
function notThing(thing) {
	return ! yesThing(thing)
}
function yesObject(thing) {
	return yesThing(thing) && typeof thing === Str_Object
}
function notObject(thing) {
	return ! yesObject(thing)
}
function yesArray(thing) {
	return yesThing(thing) && Array.isArray(thing)
}
function notArray(thing) {
	return ! yesArray(thing)
}
function yesElem(thing) {
	return yesObject(thing) && notArray(thing)
}
function notElem(thing) {
	return ! yesElem(thing)
}
function tryArg(_arg) { // error if no arg or undefined arg // use for default args
	try {
		if (yesUndefined(_arg)) {throw Str_Undefined}
	} catch(e) {throw Str_Undefined}
}
//endregion


//region JSON_
const Arr_SUCFAI	= ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9",]
const Lbl_ROLSUC_	= "Lbl_ROLSUC_"
const Lbl_ROLFAI_	= "Lbl_ROLFAI_"
//endregion


//region Elems (aka components in LR)
//region Elems Events
const Evt_Click  = "click"
const Evt_Update = "update"
function onElemEvtFct(elem, evt, fct) {
	debugFA("onElemEvtFct", arguments)
	return elem.on(evt, fct)
}
function onElemClickFct(elem, fct) {
	debugFA("onElemClickFct", arguments)
	return onElemEvtFct(elem, Evt_Click, fct)
}
function onElemUpdateFct(elem, fct) {
	debugFA("onElemUpdateFct", arguments)
	return onElemEvtFct(elem, Evt_Update, fct)
}
function onElemChildEvtFct(elem, child, evt, fct) {
	debugFA("onElemChildEvtFct", arguments)
	return elem.on(evt, child, fct)
}
function onElemChildClickFct(elem, child, fct) {
	debugFA("onElemChildClickFct", arguments)
	return onElemChildEvtFct(elem, child, Evt_Click, fct)
}
function onElemChildUpdateFct(elem, child, fct) {
	debugFA("onElemChildUpdateFct", arguments)
	return onElemChildEvtFct(elem, child, Evt_Update, fct)
}
//endregion

//region Elems Attributes
function getElemParent(elem) {
	debugFA("getElemParent", arguments)
	let result = null
	try {result = elem.parent()} // skip error when no parent
	finally {}
	return result
}
function getElemChild(elem, child) {
	debugFA("getElemChild", arguments)
	let result = null
	try {result = elem.find(child)} // skip error when no child
	finally {}
	return result
}
function getElemSheet(elem) {
	debugFA("getElemSheet", arguments)
	let result = null
	try {result = elem.sheet()} // skip error when no sheet
	finally {}
	return result
}
function getElemName(elem) {
	debugFA("getElemName", arguments)
	let result = null
	try {result = elem.name()} // skip error when no name
	finally {}
	return result
}
function getElemId(elem) {
	debugFA("getElemId", arguments)
	let result = null
	try {result = elem.id()} // skip error when no id
	finally {}
	return result
}
function getElemIndex(elem) {
	debugFA("getElemIndex", arguments)
	let result = null
	try {result = elem.index()} // skip error when no index
	finally {}
	return result
}
function getElemTypeof(elem) {
	debugFA("getElemTypeof", arguments)
	return typeof elem
}
function getElemChildren(elem) { // return children ids (get them with find)
	debugFA("getElemChildren", arguments)
	const elm_value = getElemValue(elem)
	if (notElem(elm_value)) {return []} // not an elem so no children
	return Object.keys(elm_value)
}
//endregion

//region Elems Values
function getElemValue(elem) {
	debugFA("getElemValue", arguments)
	const elm_value = elem.value()
	return Number.isNaN(Number(elm_value)) ? // right type
		elm_value : Number(elm_value)
}
//endregion

//region Elems Classes
function getElemCss(elem) {
	debugFA("getElemCss", arguments)
	let result = []
	try {result = elem.getClasses()} // skip error when no classes
	finally {}
	return result
}
//endregion
//endregion


//region Items (designed by a sheet and an item id)
function getSheetItem(sheet, item) { // returns an elem
	debugFA("getSheetItem", arguments)
	return sheet.get(item)
}
function getSheetItemChild(sheet, item, child) { // OBSO
	return sheet.get(item).value()[child]
}
function getSheetItemParent(sheet, item) { // OBSO
	return sheet.get(item).parent().id()
}
//endregion

//region Events // due to JS we cannot use Event and Function so ... Evt and Fct
// const Evt_Click  = "click"
// const Evt_Update = "update"
function onSheetItemEvtFct(sheet, item, evt, fct) {
	return sheet.get(item).on(evt, fct)
}
function onSheetItemClickFct(sheet, item, fct) {
	return onSheetItemEvtFct(sheet, item, Evt_Click, fct)
}
function onSheetItemUpdateFct(sheet, item, fct) {
	return onSheetItemEvtFct(sheet, item, Evt_Update, fct)
}
//endregion

//region Values
function getSheetItemValue(sheet, item) {
	const itm_value = sheet.get(item).value()
	return Number.isNaN(Number(itm_value)) ? // right type
		itm_value : Number(itm_value)
}
function setSheetItemValue(sheet, item, itm_value) {
	if (Array.isArray(item)) {return item.forEach(function(item) { // recursive
		setSheetItemValue(sheet, item, itm_value)
	})} // single item from here
	sheet.get(item).value(itm_value)
	return itm_value
}
function hasSheetItemValue(sheet, item, itm_value) {
	return getSheetItemValue(sheet, item) == itm_value
}
//endregion


const Css_Repeater = "repeater"
const Css_RepeaterElement = "repeater-element"
function rptElemDoIf(elem, do_fct, if_fct) { // apply fct on repeater if true
	debugFA("rptElemDoIf", arguments)
	if (arguments.length < 3) { // filter function
		if_fct = function(elem) {
			debugFA("rptElemDoIf_if_fct", arguments)
			return true // true to do action function
		}
	}
	if (arguments.length < 2) { // action function
		do_fct = function(elem) {
			debugFA("rptElemDoIf_do_fct", arguments)
			debugElem(elem, true, true)
			return true // true to continue recursive
		}
	}
	if (notElem(elem)) {return} // not an elem
	if (if_fct(elem)) {
		// if (! do_fct(elem)) {return} // /!\ repeat twice (why ?)
		const yes_recursive = do_fct(elem)
		if (! yes_recursive) {return} // interrupt recursive 
	}
	// getElemChildren(elem).forEach(function(child) // /!\ repeat twice (why ?)
	const elm_children = getElemChildren(elem) 
	elm_children.forEach(function(child) { // recursive
		rptElemDoIf(elem.find(child), do_fct, if_fct)
	})
}




init = function(sheet) {
	// initialize all the sheets
	if (sheet.id() === "main") {initMainSheet(sheet)}
	if (sheet.id() === "Dia_SHTPRF") {initPreferencesSheet(sheet)}
	if (sheet.id() === "Bnd_SCOROL") {initScoreRollBindingSheet(sheet)}
}


// Main Sheet
const initMainSheet = function(sheet) {

	const Row_SCO = "Row_SCO"
	const Lbl_Nom = "Lbl_Nom"
	const Clk_Icon = "Clk_Icon"
	const Dot_Test = "Dot_Test"
	const Val_RESULT = "Val_RESULT"
	const Row_SCO = "Row_SCO"
	const Clk_HOP = "Clk_HOP"
	const Rep_HIS = "Rep_HIS"
	const Val_HIS = "Val_HIS"
	const Rep_OBJ = "Rep_OBJ"
	const Rep_PER = "Rep_PER"
	const Chk_PHYCHK = "Chk_PHYCHK"
	const Val_PHYCHK = "Val_PHYCHK"
	const Val_OBJITM = "Val_OBJITM"
	const Val_Nom = "Val_Nom"
	const Vis_OBJITM = "Vis_OBJITM"
	const Css_BgSecondary = "bg-secondary"

	const Arr_Loop = [
		11,
		[
			22,
			[
				111,
				222,
			],
			33,
			[],
		],
		"charlie",
		null,
	]

	const Key_TEST = {
		Lbl_Nom: Lbl_Nom + " this is my name",
		dummy: {},
	}
	const Fruit = "Apple"
	Key_TEST["Fruit"] = Fruit
	Key_TEST["Arr_Loop"] = Arr_Loop

	// setSheetItemValue(sheet, Val_RESULT, strThing(10, true))
	// setSheetItemValue(sheet, Val_RESULT, strThing(10.256, true))
	// setSheetItemValue(sheet, Val_RESULT, strThing("", true))
	// setSheetItemValue(sheet, Val_RESULT, strThing("hello", true))
	// setSheetItemValue(sheet, Val_RESULT, strThing([], true))
	// setSheetItemValue(sheet, Val_RESULT, strThing([[]], true))
	// setSheetItemValue(sheet, Val_RESULT, strThing([10], true))
	// setSheetItemValue(sheet, Val_RESULT, strThing([10, 20], true))
	// setSheetItemValue(sheet, Val_RESULT, strThing(null, true))
	// setSheetItemValue(sheet, Val_RESULT, strThing(Arr_Loop, true))
	// setSheetItemValue(sheet, Val_RESULT, strThing({}, true))
	// setSheetItemValue(sheet, Val_RESULT, strThing({stuff: {}}, true))
	// setSheetItemValue(sheet, Val_RESULT, strThing(Key_TEST, true))

	debug("start")

	function argTest(_arg1, _arg2, _arg3) {
		try {tryArg(_arg1)} catch(e) {_arg1 = "Hello"}
		try {tryArg(_arg2)} catch(e) {_arg2 = "World"}
		try {tryArg(_arg3)} catch(e) {_arg3 = "!"}
		log(_arg1 + " " + _arg2 + " " + _arg3)
	}

	// argTest()
	// argTest("John")	
	// argTest("Bonjour")
	// argTest("Bonjour", "Le Monde")	
	// argTest(null, "Allan")	
	// argTest(undefined, "Willy")	
	// argTest("A", "B", "C")	
	// argTest(undefined, "B", "C")	
	// argTest("A", undefined, "C")	
	// argTest("A", "B", undefined)
	// tryArg()
	
	// log(gaiValue())
	// log(gaiValue(undefined, Int_Zero))
	log(gaiValue(undefined, 10))
	log(gaiValue(undefined, 10, Int_MOne))
	log(gaiValue(Int_POne, 10))
	log(gaiValue(undefined, 10, 20))
	
	// debug(cpoValue("   this is     THE way   "))
	// debug(cpoValue("   THIS is     THE way   "))
	// debug(cpoValue("   THIS is     THE way   ", true))
	// debug(cpaValue("   this is     THE way   "))
	// debug(cpaValue("   THIS is     THE way   "))
	// debug(cpaValue("   THIS is     THE way   ", true))
	// debug(tynValue(0))
	// debug(tynValue(1))
	// debug(tynValue(false))
	// debug(tynValue(true))
	
	setSheetItemValue(sheet, Val_HIS, 0)
	const Chk_HOPITM = "Chk_HOPITM"
	const Rep_his = getSheetItem(sheet, Rep_HIS)
	const Rep_obj = getSheetItem(sheet, Rep_OBJ)
	
	function setRep_PER() {
		const rep_value = {
			"1": {
				Val_HOPITM: "boiteux",
			},
			"2": {
				Val_HOPITM: "gÃ©nie",
			},
		}
		if (! getSheetItemValue(sheet, Rep_PER)) {
			setSheetItemValue(sheet, Rep_PER, rep_value)
		}
		return getSheetItemValue(sheet, Rep_PER)
	}
	
	function setVal_RESULT(str_result) {
		return setSheetItemValue(sheet, Val_RESULT, str_result)
	}
	
	function fakRep_OBJ() {
		return setSheetItemValue(sheet, Rep_OBJ, getSheetItemValue(sheet, Rep_OBJ))
	}
	
	onElemUpdateFct(getSheetItem(sheet, Val_Nom), function(elem) {
		debugElemUpdate(elem)
		rptElemDoIf(elem)
	})
	
	onElemClickFct(Rep_obj, function(elem) {
		debugElemClick(elem)
		debug(elem)
		setVal_RESULT("Click:\n" + strThing(getSheetItemValue(sheet, Rep_OBJ), true))
	})
	
	onElemUpdateFct(Rep_obj, function(elem) {
		debugElemUpdate(elem)
		debug(elem)
		setVal_RESULT("Update:\n" + strThing(getSheetItemValue(sheet, Rep_OBJ), true))
	})
	
	onElemChildClickFct(Rep_obj, Chk_PHYCHK, function(elem) {
		debugElemClick(elem)
		rptElemDoIf(elem)
		const elm_index = getElemIndex(elem)
		const val_phychk = Rep_obj.find(elm_index).find(Val_PHYCHK)
		// const val_phychk = elem.find(Val_PHYCHK)
		debug("--")
		onElemUpdateFct(val_phychk, function(elem) {
			debugElemUpdate(elem)
			// rptElemDoIf(elem)
			const chk_phychk = Rep_obj.find(elm_index).find(Chk_PHYCHK)
			if (getElemValue(elem)) {
				chk_phychk.addClass(Css_BgSecondary)
			} else  {
				chk_phychk.removeClass(Css_BgSecondary)
			}
		})
		debug("--")
		debugElem(val_phychk, true, true)
		debug(val_phychk.value())
		val_phychk.value(tynValue(val_phychk.value()))
		debug(val_phychk.value())
	})
	
	onElemChildClickFct(Rep_obj, Val_OBJITM, function(elem) {
		debugElemClick(elem)
		rptElemDoIf(elem)
	})
	
	onElemChildUpdateFct(Rep_obj, Val_OBJITM, function(elem) {
		debugElemUpdate(elem)
		rptElemDoIf(elem)
	})
	
	onElemChildUpdateFct(Rep_obj, Vis_OBJITM, function(elem) {
		debugElemUpdate(elem)
		rptElemDoIf(elem)
	})
	
	onElemChildClickFct(Rep_obj, Val_PHYCHK, function(elem) {
		debugElemClick(elem)
		debugElem(elem, true, true)
	})
	
	onElemChildUpdateFct(Rep_obj, Val_PHYCHK, function(elem) {
		debugElemUpdate(elem)
		debugElem(elem, true, true)
	})


	fakRep_OBJ() 
	setRep_PER()



	sheet.get(Lbl_Nom).addClass(Lbl_Nom)
	// log(sheet.get(Lbl_Nom).getClasses(Lbl_Nom))


	// const Data = sheet.getData()
	// log(Data)
	// log("Ok")
	// const Cpn_Test = sheet.get(Dot_Test)
	// log(Cpn_Test)
	// log(typeof Cpn_Test)
	// log(Cpn_Test.parent())
	// log(Object.entries(Cpn_Test))
	// log("Ok")
	
    // limit PHYMAX dec, inc
	sheet.get(Clk_Icon).on("click", function() {
		loop1(Arr_Loop, "Hello", "World")
		loop2(Arr_Loop, "Hello", "World")
		loop3(Arr_Loop, "Hello", "World")
	})

	function loop1(item, itm_value1, itm_value2) {
		debugFA("loop1", arguments)
		if (Array.isArray(item)) {
			item.forEach(function(item) {
				loop1(item, itm_value1, itm_value2)
			})
			return
		}	// recursive
		debugFA("loop1", [item + " " + itm_value1 + " " + itm_value2])
	}

	function loop2(item, itm_value1, itm_value2) {
		debugFA("loop2", arguments)
		debugFA("loop2", item)
		debugFA("loop2", itm_value1)
		debugFAOK("loop2")
		log(item)
		log(typeof item)
		log(arguments)
		log(typeof arguments)
		log(itm_value1)
		log(typeof itm_value1)
	}

	function loop3(item, itm_value1, itm_value2) {
		debugFA("loop3", arguments)
		item.flat(Infinity).forEach(function(item) {
			debugFA("loop3", [item + " " + itm_value1 + " " + itm_value2])
		})
	}
	
	onSheetItemClickFct(sheet, "Dia_SHTPRF", function() {
		const item = "Dia_SHTPRF"
		debug(item)
		sheet.prompt("Prefs", item, function(dialog) {
			setSheetItemValue(sheet, "Prf_DXVPRF", dialog.Chc_DXVPRF)
			setSheetItemValue(sheet, Val_RESULT, Object.entries(dialog))
		}, function(dialog) {
			setSheetItemValue(dialog, "Chc_DXVPRF", getSheetItemValue(sheet, "Prf_DXVPRF"))
		})
	})
	
	// log(sheet.get("Cnt_TESTS").getClasses())
	// log(sheet.get("Lbl_TESTS").getClasses())
	// sheet.get("Cnt_TESTS").hide()
	// sheet.get("Lbl_TESTS").hide()
	// log("---")
	// log(sheet.get("Cnt_TESTS").getClasses())
	// log(sheet.get("Lbl_TESTS").getClasses())
	
	
	const Val_CMASEL = "Val_CMASEL"
	const Val_SCOACT = "Val_SCOACT"
	const Val_SCOROL = "Val_SCOROL"
	const Bnd_SCOROL = "Bnd_SCOROL"

	onSheetItemClickFct(sheet, Bnd_SCOROL, function() {
		debug("onSheetItemClickFct")
		const rol_scorol = new RollBuilder(sheet)
			.expression("1d10")
			.title("Score Roll")
			.visibility("visible")
			.onRoll(function(diceresult) {
				const val_cmasel = ":fist-raised: (PHY|MEN) :brain:"
				const val_scoact = getSheetItemValue(sheet, Val_SCOACT)
				const val_scorol = diceresult.total
				setSheetItemValue(sheet, Val_SCOROL, val_scorol)
				const dif_scorol = val_scoact - val_scorol
				if (dif_scorol >= 0) {
					const lbl_sucfai = _(Lbl_ROLSUC_)
					const val_sucfai = "+" + dif_scorol
				} else {
					const lbl_sucfai = _(Lbl_ROLFAI_)
					const val_sucfai = "" + dif_scorol
				}
				const bna_scorol = lbl_sucfai + " " + val_sucfai
		
				Bindings.clear(Val_SCOACT)
				Bindings.add(bna_scorol, Val_SCOACT, Bnd_SCOROL, function() {
					debugOK()
					return {
						Lbl_SUCFAI: lbl_sucfai,
						Val_SUCFAI: val_sucfai,
						Val_CMASEL: val_cmasel,
						Val_SCOACT: val_scoact,
						Val_SCOROL: val_scorol,
					}
				})
				Bindings.send(sheet, bna_scorol)
			})
			.roll()
	})


	
	onSheetItemClickFct(sheet, Clk_HOP, function() {
		const item = Clk_HOP
		debug(item)
		const Rep_his = getSheetItemValue(sheet, Rep_HIS)
		debug("> Rep_his")
		debug(Rep_his)
		debug(sheet.get(Rep_HIS).getClasses())
		setSheetItemValue(sheet, Val_RESULT, strThing(Rep_his))
		// each(Rep_his, function(entryData, entryId) {
			// debug(">> entryData"); debug(entryData)
			// debug(">> entryId"); debug(entryId)
			// let entry = sheet.get(Rep_HIS).find(entryId)
			// debug(">> entry"); debug(entry)

            // if (entryData.attackSt && entryData.attackSt != "0") {
                // attackSavingThrowLabel = _(Attributes.get(entryData.attackSt).name);
                // entry.find("attackSavingThrowLabel").text(attackSavingThrowLabel);
            // } else entry.find("attackSavingThrowRow").hide();
		// })
		Object.keys(Rep_his).forEach(function(key_typ, idx_typ) {
			debug(">> key_typ " + strThing(key_typ))
			debug(">> idx_typ " + strThing(idx_typ))
			debug(Rep_his[key_typ])
			debug(getSheetItemChild(sheet, Rep_HIS, key_typ))
			// debug(sheet.get(Rep_HIS).value().find(key_typ))
			// debug(getSheetItemParent(sheet, key_typ))
		})
	})
}


const initPreferencesSheet = function(sheet) {
	debug("initPreferencesSheet")

	onSheetItemClickFct(sheet, "Set_DXVPRF", function() {
		debugOK()
		setSheetItemValue(sheet, "Chc_DXVPRF", "both")
	})

	onSheetItemClickFct(sheet, "Get_DXVPRF", function() {
		debugOK()
		setSheetItemValue(sheet, Val_RESULT, getSheetItemValue(sheet, "Chc_DXVPRF"))
	})

}


const initScoreRollBindingSheet = function(sheet) {
	debug("initScoreRollBindingSheet")
	
	if (getSheetItemValue(sheet, "Lbl_SUCFAI") == _(Lbl_ROLSUC_)) {
		sheet.get("Row_SUCFAI").addClass("text-success")
	} else {
		sheet.get("Row_SUCFAI").addClass("text-danger")
	}
}
